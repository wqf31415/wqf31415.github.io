---
title: Rust学习笔记3-Rust核心概念之所有权与生命周期
tags:
  - 开发
  - Rust
categories:
  - Rust
date: 2024-06-03 23:32:24
---

### 概述

这篇文件介绍了 Rust 中最核心，也是最难理解的两个概念：所有权和生命周期，想学好 Rust 就必须充分的理解这两个概念。所有权是 Rust 最特别的一个理念，所有权让 Rust 在无需垃圾回收机制就可以保证内存安全，在其他编程中没有所有权的概念，因此从其他编程语言转来学 Rust 时会难以理解。生命周期在大多数编程语言中都有，但都是隐式的，在 Rust 中可以显式的指定生命周期，这也是 Rust 所独有的。



### 概念理解

所有权是 Rust 的核心特性，Rust 中使用所有权系统来管理内存使用，所有权机制不像 java、C# 使用垃圾回收器管理内存，也不像 C 语言一样需要程序员显式的申请与释放内存。

所有权系统让 Rust  在编译时就可以完成内存使用的检查，因而不产生任何程序运行时开销，既保证了内存安全，又提升了运行速度。

<!-- more -->



### Rust 所有权三大规则

- **Rust 中每个值都有一个变量，这个变量就是这个值的所有者。**
- **同一时刻一个值只能有一个所有者。**
- **当所有者离开作用域时，该值将被删除，内存将被释放。**

> 在 Rust 的世界中，每个内存空间都有且只有一个所有者，如果所有者不在了，内存空间也会被释放。
>
> 就像每个灵魂都要有一个躯体，每个躯体里只能容纳一个灵魂，如果躯体死了，灵魂就会消逝。



### 关于栈（stack）存储和堆（heap）存储

计算机为每个运行的程序分配内存资源，程序在运行时管理和使用内存资源。在计算机内存中只存储程序运行状态时的所有变量、常量。

对于常量和静态变量，它们的生命周期从程序运行开始到程序终止，将被存储在**静态内存区**，这类数据在程序开始运行时被分配，运行结束时被释放。

对于函数中的变量，其生命周期很灵活，在函数调用时开始到函数返回时结束，这类数据将以栈的数据结构来管理，存储此类数据的内存区域被称为**栈区**，栈区内存空间有限，由操作系统自动分配和释放。

程序中还有一些大小不确定的数据，无法在编译时确定大小，只能在运行时由程序向系统申请存储空间，在这些数据不在被使用时由程序释放。这些数据以堆的数据结构存储，存储此类数据的内存空间被称为**堆区**，栈区内存空间很大，需要程序申请分配和释放。

> Rust 之前的程序内存管理方式：
>
> 1、手动管理：以 C 语言为代表，需要手动申请分配内存，如使用 `malloc()` 函数分配内存，使用结束后需要手动释放内存，如使用 `free()` 函数释放内存。
>
> 2、垃圾回收：以 JAVA 为代表，分配内存使用 `new` 关键字，JAVA 虚拟机提供了垃圾回收机制，自动回收不再使用的资源。
>
> Rust 的程序内存管理方式：所有权



### 所有权的应用

#### 移动（Move）

当一个值被赋值给另一个变量或作为函数参数传递时，其所有权会被移动到另一个变量。如 `String` 类型的变量被赋值给另一个变量后，其所有权将被移动给新变量，原变量将不可用。



#### 复制（Copy）

如果一个变量实现了 `Copy` trait ，这个变量在赋值后仍然可用。

如果一个类型或该类型的一部分实现了 `Drop` 的 trait ，Rust 不允许它再实现 `Copy` trait 。

一些实现 `Copy` trait 的类型：

- 任何简单标量的组合类型都是可以 Copy 的
- 任何需要分配内存或某种资源的都不是 Copy 的
- 所有的整数类型都是可以 Copy 的
- bool 类型
- char 类型
- 所有浮点型
- 如果元组的所有字段都是可 Copy 的，那么此元组是可 Copy 的



#### 克隆（Clone）

使用 `clone` 方法可以创建数据的深拷贝，即栈和堆的数据都会被拷贝一份。



#### 借用（Borrowing）

借用可以在不转移数据所有权的情况下使用该数据。
